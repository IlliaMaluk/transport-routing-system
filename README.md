# Transport Routing System

A thesis-grade web system for computing optimal routes in transport networks. The stack combines a FastAPI backend, a Rust/PyO3 routing core for parallel path search, and a React + Leaflet frontend for interactive exploration.

## Architecture
- **Rust routing core (`core/`)**: PyO3 module (`routing_core`) implements Dijkstra and A* plus parallel batch variants for multi-query execution.
- **Backend (`backend/`)**: FastAPI + SQLite with endpoints for graph import/editing, routing, quality checks, scenarios, optimization profiles, async job monitoring, and query history.
- **Frontend (`frontend/`)**: React/TypeScript UI that visualizes routes, submits single/batch queries, shows stats/history, and handles simple auth UI flows.

## Quick start
### Prerequisites
- Python 3.10+
- Rust toolchain + `maturin` (`pip install maturin`)
- Node.js 18+

### 1) Build the Rust routing core
```bash
cd core
maturin develop  # builds and installs routing_core into the current Python environment
```

### 2) Run the FastAPI backend
```bash
cd backend
python -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt
uvicorn app.main:app --reload --host 0.0.0.0 --port 8000
```
- SQLite database `routing.db` is created in `backend/`.
- CORS is open for all origins for easier frontend dev.

### 3) Start the React frontend
```bash
cd frontend
npm install
npm run dev -- --host --port 5173
```
- During local dev the Vite dev server proxies `/api` to `http://localhost:8000`, so keep the backend running on port 8000.
- If your backend lives elsewhere (e.g., Docker compose hostname or HTTPS gateway), set `VITE_API_URL` in a `.env` file, e.g. `VITE_API_URL=https://my-host.example.com/api`.

## How the functional requirements map
Implemented highlights:
- Graph management: CSV import with metadata persistence, node/edge bulk creation, and quality checks/fixes (isolated nodes, zero-weight cycles).
- Routing: single-route search via Dijkstra or A*, parallel batch routing, and async job tracking with performance/history logging.
- Optimization context: basic profiles (time/distance/cost weights, transfer penalty) and scenario modelling with edge overrides or disables.
- Interfaces: REST API for all features and a web UI with map visualization, stats, and history panels.

Gaps and partial coverage to plan next:
- Import formats beyond CSV (GeoJSON/OSM extracts) are not implemented.
- No interactive network editing on the map or rich metadata editing UI.
- Multi-criteria optimization is modelled in DTOs/profiles but weights are not applied in the Rust core; GPU acceleration is absent.
- Limited reporting: no autogenerated PDFs/graphs; monitoring is basic.
- Authentication/roles exist in the API, but there is no provisioning flow or secure production CORS setup.

## Repository layout
- `core/`: Rust routing core exposed via PyO3.
- `backend/`: FastAPI app, SQLAlchemy models, routing/scenario/quality services.
- `frontend/`: React + Leaflet client.

## Notes
- For production, harden auth/CORS, move off SQLite, and add HTTPS in front of both services.
- Benchmarks and geo-data import scripts are intentionally out of scope of this sample; extend them to meet full thesis requirements.
